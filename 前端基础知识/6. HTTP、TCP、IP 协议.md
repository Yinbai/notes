# HTTP、TCP/IP 协议

## 在浏览器地址栏输入链接并跳转后发生了什么

1. **找服务器 IP 地址**

   浏览器获取到输入的地址后，会获取到一个域名，而在实际的通信过程中浏览器需要的是一个 IP 地址。为了获取这个 IP 地址，浏览器会做以下操作，这个过程叫做 **DNS 解析**

   1. 先在浏览器的本地缓存中查找域名对应的 IP 地址
   2. 如果以上找不到，就在电脑硬盘中的 host 文件中查找是否有这个域名和 IP 的映射关系
   3. 如果以上找不到，就通过网络去域名服务商那里查询

2. **建立 TCP/IP 连接**

   1. 浏览器获取到 IP 地址后，就会向对应的 IP 服务器发送 TCP 连接请求

   2. 服务器收到浏览器请求后，双方多次确认后建立 TCP 双向连接

   > 从客户端发起连接请求一直到 `TCP` 连接建立，这个过程，叫做 `三次握手`。
   >
   > 如果是 HTTPS 请求，还需要在 `TCP` 连接上，再通过 `SSL` 或 `TLS` 处理加密数据、身份验证及数据完整性，来保证数据传输的安全性。

3. **请求资源**

   1. TCP 连接创建完成后，浏览器向服务器发送正式的 HTTP/HTTPS 请求的数据包
   2. 服务器接收请求，对请求进行解析，经过数据操作后，向浏览器发送响应数据包

4. **浏览器渲染**

   1. 浏览器拿到数据后，对数据进行操作，渲染出页面

5. **浏览器缓存**

   浏览器拿到数据后，会根据一些策略来进行数据缓存，这样在下一次请求同样的数据时直接去浏览器缓存中获取，不需要再请求服务端

## 经典网络五层模型

在每一台计算机设备上，都有这样的一套系统链路，来保证网络传输的正常进行。

#### 应用层

包含了 HTTP 协议，应用层不关心底层细节，作为应用支持，为应用软件提供服务。常见的应用层服务有：HTTP、FTP、Email 等

#### 传输层

常见的传输层协议有 TCP 和 UDP，传输层作为应用层的基础，定义了端到端之间数据传输方式，比如两台设备之间数据怎样建立连接、按照怎样的规范进行数据传输，这些都是传输层定义的

#### 网络层

常见的 IP 协议就在这一层，网络层为数据在节点之间传递创建逻辑链路，当我们在浏览器输入地址敲下回车后，浏览器如何根据域名查找对应 IP，这个查询的逻辑关系就是网络层定义的

#### 数据链路层

数据链路层在通讯实体之间建立数据链路连接，物理设备连接完成后，需要相应的软件和驱动来连接和打通这些设备，创建电路的连接。

#### 物理层

定义物理设备如何传输数据，常见的物理层有光缆、网线、网卡，物理层是一切软件的基础。

## URI、URL 和 URN

#### URI

Uniform Resource Identifier，统一资源标识符。每一个 web 服务器都有一个 URI 标识符，它在世界范围内唯一标识并定位信息资源。一个资源信息有了 URI 之后，在互联网上就可以通过一个固定地址访问到这个资源。

它具有两种形式，一种是 URL（统一资源定位符），另一种是 URN（统一资源名），也就是说 `URL` 和 `URN` 是它的子集。

#### URN

Uniform Resource Name，统一资源名。它的作用是永久定位资源，因为同一个资源可能会更换存储位置，存储位置一旦更换，URL 也会发生改变。URN 就是解决这个问题的，不管资源存储位置如何变化，只要访问同一个 URN 都能定位到。

## TCP/IP 协议族

TCP/IP（传输控制协议/互联网协议）协议族不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是 `TCP` 和 `IP`。因此我们习惯将整个协议族称为 `TCP/IP`。

#### TCP 协议

`TCP` 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 `TCP` 连接通道下向对端接收和发送数据。

`TCP` 相比于 `UDP` 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。

`TCP` 相比于 `UDP` 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。

每台服务器可提供支持的 `TCP` 连接数量是有限的，所以这也使得 `TCP` 连接变成了稀缺资源，经不起浪费。

#### UDP 协议

`UDP` 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。

`UDP` 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。

`UDP` 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 `UPD` 提供了单播、多播、广播的功能。

`UDP` 相比于 `TCP` 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 `UDP`，比如直播、视频会议、LOL等实时对战游戏。

`UDP` 相比于 `TCP` 的劣势在于它的不可靠性和不稳定性。

## TCP 连接

在客户端发送正式的 `HTTP` 请求之前，需要先创建一个 `TCP` 连接，在创建的 `TCP Connect`  通道下，所有的 `HTTP` 请求和响应才能正常的发送和接受。

在不同的 `HTTP` 协议版本里，这个 `TCP` 连接通道的创建和持续机制也有所不同。

- 在 `HTTP1.0` 中，每一次 `HTTP` 请求都会创建一个 `TCP` 连接，在请求发送完成，服务器响应以后，这个 `TCP` 连接就自动断开了。
- 在 `HTTP1.1` 中，可以通过手动设置 `Connection： keep-alive` 请求头来建立 `TCP` 的持久连接，多个 `HTTP` 请求可以共用一个 `TCP` 连接。但是 `TCP` 连接存在线头阻塞，即若干个请求排队等待发送，一旦有某请求超时等，后续请求只能被阻塞。
- 在 `HTTP2` 中，采用了信道复用，使 `TCP` 连接支持并发请求，即多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行吗，这样一来，大部分请求可以使用一个 `TCP` 连接，而不用创建新的 `TCP` 连接通道，既节省了三次握手的开销，又节约了服务端维护 `TCP` 端口的成本。

## TCP 的三次握手和四次挥手

#### 三次握手

![06-01](/Users/Cuptea/Documents/Work/notes/images/06-01.png)

> 关于 `ACK`、`FIN`、`SYN` 状态码的含义
>
> 1. `ACK` 用于确认，表示通知对方，我已经收到你发来的信息了。
> 2. `FIN` 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。
> 3. `SYN` 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。

1. 第一次握手：由客户端向服务端发送连接请求 `SYN` 报文，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 `SYN-SENT` 状态。
2. 第二次握手：服务端收到连接请求报文段后，如果同意连接，**则会发送一个包含了 `ACK` 和 `SYN` 报文信息的应答，该应答中也会包含自身的数据通讯初始序号**（在断开连接的“四次挥手”时，`ACK` 和 `SYN` 这两个报文是作为两次应答，独立开来发送的，因此会有四次挥手），服务端发送完成后便进入 `SYN-RECEIVED` 状态。
3. 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 `ESTABLISHED` 状态，服务端收到这个应答后也进入 `ESTABLISHED` 状态，此时连接建立成功。

> 面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？ 因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。 然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 `TCP` 连接端口，在那里呆等客户端。 而服务端能维护的 `TCP` 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。 因此在服务端发送了 `SYN` 和 `ACK` 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题。

#### 四次挥手

![06-02](/Users/Cuptea/Documents/Work/notes/images/06-02.png)

和建立 `TCP` 连接类似，断开 `TCP` 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。

1. 第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 `FIN` 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 `FIN_WAIT_1` 状态。
2. 第二次挥手：服务端收到客户端发送回来的 `FIN` 以后，会告诉应用层要释放 TCP 链接，并且发送一个 `ACK` 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 `CLOSE_WAIT` 的状态。
3. 第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 `FIN` 请求用来关闭服务端到客户端的数据传送，然后服务端进入 `LAST_ACK` 状态。
4. 第四次挥手：客户端接收到服务端的 `FIN` 请求后，发送最后一个 `ACK` 给服务端，接着进入 `TIME_WAIT_2` 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 `CLOSED` 状态.服务端在收到应答消息后，也会进入 `CLOSED` 状态，至此完成四次挥手的过程，双方正式断开连接。



用一段人话来描述整个过程：

1. 客户端：喂，我好了。
2. 服务端：噢，你好了是吧，我知道了，我还没好，你等一哈。
3. 服务端：OK，现在我也好了。
4. 客户端：收到，这次玩的很开心，我们下次再约。

> 可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？ 这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 `SYN` 报文后，会把 `ACK` 和 `SYN` 放在一个报文里发送给客户端。 而关闭连接时，服务端收到客户端的 `FIN` 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 `FIN` 报文，只能先发送 `ACK` 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 `FIN`。 所以，在断开连接时，服务器的 `ACK` 和 `FIN` 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。





## 名词解释

TCP：Transmission Control Protocol，传输控制协议。

UDP：User Datagram Protocol，用户数据报协议。

IP：Internet Protocol，国际互连协议。

DNS：Domain Name System，域名系统（服务）协议。

SSL：Secure Sockets Layer，安全套接字协议。

TLS：Transport Layer Security，传输层安全协议。

