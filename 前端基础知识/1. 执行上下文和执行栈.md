# 执行上下文和作用域（ES6）

从概念上来讲，ES6 的执行上下文类似于：

```
ExecutionContext = {
	ThisBinding = <this value>,
	LexicalEnvironment = {...},
	VariableEnvironment = { ... }
}
```



## 词法环境

**词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由**环境记录器**和一个可能的引用**外部词法环境**的空值组成。

> 词法环境是 Javascript 作用域的内部实现机制，通常称为作用域（scope）。

##### 使用词法环境跟踪变量的作用域

- **代码嵌套**

  词法环境主要基于代码嵌套，通过代码嵌套可以实现代码结构包含另一种代码结构。

  ```javascript
  <script>
  	var f = "Hope";
  	function foo() {
  		var action = "eating";
  		function report() {
  			var count = 3;
  			for (var i = 0; i < count; i++) {
  				console.log(f + " " + action + " " + i);
  			}
  		}
      report();
  	}
  	foo();
  </script>
  ```

  在作用域范围内，每次执行代码时，代码结构都获得与之关联的词法环境，内部代码结构可以访问外部代码结构中定义的变量。Javascript 引擎是如何跟踪这些变量的呢，如何判断可访问性呢？这就是词法环境的作用。

- **代码嵌套与词法环境**

  除了跟踪局部变量、函数声明、函数的参数和词法环境外，还有必要跟踪外部（父级）词法环境。如果在当前环境中无法找到某一标识符，就会对外部环境进行查找。一旦查找到匹配的变量，或是在全局环境中仍然无法查找到对应的标识符而返回错误，就会停止查找。



## 变量环境

**变量环境**也是一个**词法环境** ，所以它有着词法环境的所有特性。

之所以在 `ES5` 的规范里要单独分出一个变量环境的概念是为 `ES6` 服务的： 在 `ES6` 中，**词法环境**组件和 **变量环境** 的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

> 在上下文创建阶段，引擎检查代码找出变量和函数声明，变量最初会设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误。



在 Javascript 中，我们可以通过 3 个关键字定义变量：var、let 和 const。这 3 个关键字有两点不同：可变性、与词法环境的关系。

- **变量可变性**

  如果通过变量的可变性来进行分类，可以将 var 和 let 放在一组，const 放在一组。通过 var 或 let 声明的变量可以任意改变值，通过 const 定义的变量都不可变。

- **定义变量的关键字与词法环境的关系**

  如果通过与词法环境的关系来进行分类，可以将 var 分为一组，let 和 const 分为一组。

  - 关键字 var

    此时变量是在距离最近的函数内部或是全局词法环境中定义的（忽略块级作用域）。

  - 关键字 let 和 const

    此时变量是在距离最近的词法环境中定义的（可以是块级作用域、循环内、函数内或全局环境内）。

- **在词法环境中注册标识符**

  Javascript 代码的执行事实上是分两个阶段进行。

  第一阶段：

  没有执行代码，但是 Javascript 引擎会访问并注册在当前词法环境中所声明的变量和函数。

  第二阶段：

  具体如何执行取决于变量的类型（var、let、const 和函数声明）以及环境类型（全局环境、函数环境或块作用域）。

  具体处理过程：

  1. 如果是创建一个函数环境，那么创建形参及函数参数的默认值，如果是非函数环境，跳过此步骤
  2. 如果是创建全局或函数环境，就扫描当前代码进行函数声明（不会扫描其他函数的函数体），但是不会扫描函数表达式和箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过次步骤
  3. 在函数或全局环境中，扫描当前代码进行变量声明，找到所有当前函数以及其他函数之外通过 var 声明的变量，并找到所有在其他函数或代码块之外通过 let 或 const 定义的变量。在块级环境中，仅查找当前块中通过 let 或 const 定义的变量。对于所查找到的变量，若该标识符不存在，进行注册并将其初始化为 undefined。若该标识符已经存在，将保留其值



## 程序执行的大致过程

1. 程序启动，创建全局执行上下文
   1. 创建全局上下文的词法环境
      1. 创建**对象环境记录器**，它用来定义出现在**全局上下文**中的变量和函数的关系（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **对象外部环境引用**，值为 **`null`**
   2. 创建全局上下文的变量环境
      1. 创建**环境记录器**，它持有**变量声明语句**在全局上下文中的绑定关系（负责处理 `var`定义的变量，初始值为 `undefined`）
      2. 创建 **外部环境引用**，值为 **`null`**
2. 函数被调用，函数上下文被创建
   1. 创建函数上下文的词法环境
      1. 创建**声明式环境记录器**，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `let` 和 `const` 定义的变量）
      2. 创建**外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
   2. 创建函数上下文的变量环境
      1. 创建**声明式环境记录器**，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建**外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
   3. 确定 `this` 值
3. 进入函数执行上下文的执行阶段
   1. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值



## 执行上下文栈

当一段脚本运行起来的时候，可能会调用很多函数并产生很多函数执行上下文，那么问题来了，这些执行上下文该怎么管理呢？为了解决这个问题，`javascript` 引擎就创建了 “执行上下文栈” （`Execution context stack` 简称 `ECS`）来管理执行上下文。

顾名思义，执行上下文栈是栈结构的，因此遵循 `LIFO`（后进先出）的特性，代码执行期间创建的所有执行上下文，都会交给执行上下文栈进行管理。

当 JS 引擎开始解析脚本代码时，会首先创建一个**全局执行上下文**，压入栈底（这个全局执行上下文从创建一直到程序销毁，都会存在于栈的底部）。

每当引擎发现一处函数调用，就会创建一个新的**函数执行上下文**压入栈内，并将控制权交给该上下文，待函数执行完成后，即将该执行上下文从栈内弹出销毁，将控制权重新给到栈内上一个执行上下文。



## 测验

1. ```javascript
   foo();
   
   var foo = function foo() {
       console.log('foo1');
   }
   
   function foo() {
       console.log('foo2');
   }
   
   foo();
   ```

   全局执行环境自动创建，过程中生成了变量对象进行函数变量的属性收集，造成了函数声明提升、变量声明提升。由于函数声明提升更加靠前，且如果 `var` 定义变量的时候发现已有同名函数定义则跳过变量定义，上面的代码其实可以写成下面这样：

   ```javascript
   function foo () {
       console.log('foo2');
   }
   
   foo();
   
   foo = function foo() {
       console.log('foo1');
   };
   
   foo();
   ```



2. ```javascript
   var foo = 1;
   function bar () {
       console.log(foo);
       var foo = 10;
       console.log(foo);
   }
   
   bar();
   ```

   `bar` 函数运行，内部变量申明提升，当执行代码块中有访问变量时，**先查找本地作用域**，找到了 `foo` 为 `undefined` ，打印出来。然后 `foo` 被赋值为 `10` ，打印出 `10`。



3. ```javascript
   var foo = 1;
   function bar () {
       console.log(foo);
       foo = 2;
   }
   bar();
   console.log(foo);
   ```

   这题也是考察的作用域链查找，`bar` 里操作的 `foo` 本地没有定义，所以应该是上层作用域的变量。



4. ```javascript
   var foo = 1;
   function bar (foo) {
       console.log(foo);
       foo = 234;
   }
   bar(123);
   console.log(foo);
   ```

   运行 `bar` 函数的时候将 `123` 数字作为实参传入，所以操作的还是本地作用域的 `foo`。



5. ```javascript
   var a = 1;
   
   function foo () {
       var a = 2;
       return function () {
           console.log(a);
       }
   }
   
   var bar = foo();
   bar();
   ```

   这道题目主要考察闭包和函数作用域的概念，我们只要记住：**函数能够访问到的上层作用域，是在函数声明时候就已经确定了的，函数声明在哪里，上层作用域就在哪里，和拿到哪里执行没有关系**。这道题目中，匿名函数被作为闭包返回并在外部调用，但它内部的作用域链引用到了父函数的变量对象中的 `a` ，所以作用域链查找时，打印出来的是 `2`。



6. ```javascript
   "use strict";
   var a = 1;
   
   function foo () {
       var a = 2;
       return function () {
           console.log(this.a);
       }
   }
   
   var bar = foo().bind(this);
   bar();
   ```

   这题考察的是执行环境中的 `this` 指向的问题，由于闭包内明确指定访问 `this` 中的 `a` 属性，并且闭包被 `bind` 绑定在全局环境下运行，所以打印出的是全局对象中的 `a`。



## 总结

当函数运行的时候，会生成一个叫做 “执行上下文” 的东西，也可以叫做执行环境，它用于保存函数运行时需要的一些信息。

所有的执行上下文都会被交给系统的 “执行上下文栈” 来管理，它是一个栈结构数据，全局上下文永远在该栈的最底部，每当一个函数执行生成了新的上下文，该上下文对象就会被压入栈，但是上下文栈有容量限制，如果超出容量就会栈溢出。

执行上下文内部存储了包括：**变量对象**、**作用域链**、**this 指向** 这些函数运行时的必须数据。

变量对象构建的过程中会触发变量和函数的声明提升。

函数内部代码执行时，会先访问本地的变量对象去尝试获取变量，找不到的话就会攀爬作用域链层层寻找，找到目标变量则返回，找不到则 `undefined`。

一个函数能够访问到的上层作用域，在函数创建的时候就已经被确定且保存在函数的 `[[scope]]` 属性里，和函数拿到哪里去执行没有关系。

一个函数调用时的 `this` 指向，取决于它的调用者，通常有以下几种方式可以改变函数的 `this` 值：对象调用、`call`、`bind`、`apply`。



## 问题

1. 词法环境是函数被调用时创建还是函数被创建时创建？



## 相关参考

- [JavaScript 深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/4)
- [JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)
- [图解Javascript——变量对象和活动对象](https://www.cnblogs.com/ivehd/p/vo_ao.html)
- [[译\] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-1)
- [What is the execution context in javascript](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)
- [Understanding Execution Context and Execution Stack in Javascript](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)
- [理解Javascript之执行上下文(Execution Context)](https://www.cnblogs.com/MinLee/p/5862271.html)
- [知乎：JS中的作用域链是在什么时候建立的？](https://www.zhihu.com/question/36751764)
- [VO、AO、执行环境和作用域链](https://www.cnblogs.com/lulin1/p/9712311.html)
- [尾调用优化](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)
- [JavaScript调用栈、尾递归和手动优化](https://www.jianshu.com/p/3182429e26b5)

