# Javascript 线程

> Javascript 是**单线程**，这一点是明确的。

为什么 Javascript 要被设计成单线程呢 ?

**暂且认为**是这样的：因为 Javascript 的主要用途是在浏览器端供用户进行交互操作，如果两段 Javascript 代码被分发到两个互不相关的线程上并行执行，一个线程在 DOM 上添加内容,一个线程在 DOM 上删除内容，那么最终结果如何确定。正是为了避免复杂性，Javascript 一开始就被设计成单线程。

## 进程和线程

说到线程，就不得不提**进程**。可以理解为进程就是运行的一个程序，在电脑的任务管理器中可以查看正在运行的进程。而在浏览器环境中，一个标签页就是一个进程。

一个进程需要一个或多个线程互相配合，比如打开微信这个进程，可能同时有收发消息线程、传输文件线程，等等...所以一个网页进程能够正常运行，也需要一个或多个线程配合。其主要的线程包含：

1. GUI 渲染线程
2. JS 引擎线程
3. 定时器触发线程 (setTimeout)
4. 浏览器事件线程 (onclick)
5. http 异步线程
6. EventLoop 轮询处理线程

其中，1、2、4 为常驻线程。

## 浏览器中的各种线程

了解了进程和线程就能明白，Javascript 引擎线程仅仅是浏览器多线程中的一支。我们之所以能在浏览器中实现异步请求、事件触发、定时器等等操作，都是源于浏览器的其他线程。浏览器的线程可以分为以下几类：

类别 A：GUI 渲染线程

类别 B：JS 引擎线程

类别 C：EventLoop 轮询处理线程

类别 D：其他线程，包含定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)等等

**注意**：类别 A 和类别 B 是互斥



接下来按照类别逐一分析浏览器中的各类线程。

### 类别 B

JS 引擎线程，我们把它称为**主线程**，它是干嘛的 ? 即运行 JS 代码的那个线程（不包括异步的那些代码）。比如：

```javascript
1. var a = 2;
2. setTimeout()
3. ajax()
4. console.log()
```

以上代码中，1 和 4 是同步代码，直接有主线程执行，2 和 3 分别交由其他线程处理。

主线程运行 JS 代码时，会生成执行栈。

### 类别 D

定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)。主线程执行 JS 代码时，碰到异步代码，就把它丢给各自相对应的线程去执行。比如：

```javascript
1. var a = 2;
2. setTimeout(fun A)
3. ajax(fun B)
4. console.log()
5. dom.onclick(func C)
```

以上代码中，主线程执行到 2 时，遇到 setTimeout()，就会把它交给定时器触发线程去处理；执行到 3 时，遇到 ajax()，就会把它交给 http 异步线程去处理；执行到 4 时，会直接执行；执行到 5 时，遇到事件绑定，会把它交给浏览器事件线程去处理。

这几个线程在处理上各有不同，分别是：

1. 对于 setTimeout 代码，定时器触发线程在接收到代码时就开始计时，**时间到了将回调函数扔进队列**。

2. 对于 ajax 代码，http 异步线程立即发起 http 请求，**请求成功后将回调函数扔进队列**。

3. 对于 dom.onclick，浏览器事件线程会先监听 dom，直到 **dom 被点击了，才将回调函数扔进队列**。

**注意**： 这几个异步代码的回调函数 fun A  / fun B / fun C，会被各自的线程保存着，因为在将来的某个时候，需要将回调函数交给主线程去执行

因此，这几个线程所做的工作可以总结为：

1. 执行主线程丢过来的异步代码
2. 保存回调函数，在将来的某个时刻，通知 EventLoop 轮询处理线程来取相应的回调函数，最后再执行

#### 消息队列（任务队列）

可以理解为一个静态的队列存储结构，非线程，只做存储，里面存的是一堆异步成功后的回调函数**字符串**，肯定是先成功的异步的回调函数在队列的前面，后成功的在后面。看代码：

```javascript
setTimeout(() => {
    console.log(1)
}, 2000)
setTimeout(() => {
    console.log(2)
}, 3000)
```

在一开始，消息队列是空的，2 秒后，一个 `() => { console.log(1) }` 进入了消息队列，在 3 秒后，一个 `() => { console.log(2) }` 进入了消息队列，此时队列里有两个元素，按照先进先出的原则，主线程会从队列头挨个取出回调并执行。

**注意**：是异步成功后，才把其回调函数扔进队列中，而不是一开始就把所有异步的回调函数扔进队列。比如 setTimeout 3 秒后执行一个函数，那么这个函数是在 3 秒后才进队列的。

### 类别 C

EventLoop 轮询处理线程

通过上面我们已经知道了三点：

1. 主线程处理同步代码
2. 类别 D 的几个线程处理异步代码
3. 消息队列存储这异步成功后的回调函数，是一个静态存储结构

EventLoop 轮询处理线程的作用就是



此时，需要一位灵魂画手：

~我是图.jpg

看图，加深印象

![线程-1](/Users/Cuptea/Documents/Work/notes/images/线程-1.png)

![线程-2](/Users/Cuptea/Documents/Work/notes/images/线程-2.png)

## 宏任务和微任务

上面的消息队列，可以细分为两种：

1. 宏任务（macro-task）

   - `script` 代码
   - `setTimeout`、`setInterval`、`setImmediate`、`requestAnimationFrame`
   - I/O
   - UI 交互
   - UI 渲染

   **注意**：一个 `setTimeout` 就相当于一个宏任务，所以队列里一堆回调函数都可以看成是一个一个的任务

2. 微任务（micro-task）

   - Promise.then
   - Async / Await
   - process.nextTick（Node.js 环境）
   - MutationObserver



每当主线程执行完一个宏任务，就会去微任务队列查看是否有可执行的微任务

- 如果有，就执行微任务，如果在执行过程中产生了新的微任务，就会继续执行微任务，直到微任务队列清空，主线程会开始执行下一个宏任务。
- 如果没有，就执行下一个宏任务，执行完这个宏任务之后，再去微任务队列查看是否有可执行的微任务

综上所述，形成了一个事件循环，用一张图简单的描述：

![线程-3](/Users/Cuptea/Documents/Work/notes/images/线程-3.png)

还有两张图以供参考，

![线程-4](/Users/Cuptea/Documents/Work/notes/images/线程-4.png)

![线程-5](/Users/Cuptea/Documents/Work/notes/images/线程-5.png)