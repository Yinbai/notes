# HTTP、TCP/IP面试题



1. ### OSI 网络模型

   应用层（HTTP/FTP）、表示层、会话层、传输层（TCP）、网络层（IP）、数据链路层、物理层

2. ### TCP/IP 网络模型

   应用层、传输层、网络层、数据链路层、物理层

3. ### TCP 和 UDP 的区别

   TCP 和 UDP 都是传输层的协议，区别如下

   TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。

   | TCP          | UDP            |
   | ------------ | -------------- |
   | 面向连接     | 无连接         |
   | 保证可靠交付 | 不保证可靠交付 |
   | 面向字节流   | 面向数据报     |
   | 点对点传播   | 广播           |
   | 有序         | 无序           |
   | 有状态       | 无状态         |

4. ### TCP 的三次握手和四次挥手

   **三次握手**

   - 客户端发起请求数据包，将 SYN 标志位设为 1，随机产生 Sequence Number 为 x，客户端进入 `SYN-SEND` 状态，等待服务端的确认
   - 服务端收到客户端的数据包，检测到已经设置了 SYN 标志位，知道这是客户端发来的建立连接的『请求包』。服务端也会组建一个数据包，并设置 ACK 为 x + 1，SYN 位置为 1，随机产生 Sequence Number 为 y；随后服务端将这个数据包发送给客户端，服务端进入 `SYN-RECEIVED` 状态
   - 客户端收到服务器的数据包，检测到已经设置了 SYN 和 ACK 标志位，知道这是服务端发来的建立连接的『确认包』。客户端会检测 ACK，看它的值是否是 x + 1。如果是，客户端继续组建数据包，并设置 ACK 为 y + 1，然后向服务器发送 ACK 数据包。这个数据包发送之后，客户端进入 `建立连接` 状态，三次握手完成
   - 服务端收到客户端的数据包，检测到已经设置了 ACK 标志位，知道这是客户端发来的建立连接的『确认包』。服务端会检测 ACK，看它的值是否是 y + 1，如果是就说明连接建立成功，服务端进入 `建立连接` 状态。
   - 至此，客户端和服务端之间的连接建立完成，可以收发数据

   **四次挥手（可以是客户端发起，也可以是服务端发起）**

   - 客户端设置 Sequence Number 和 ACK，向服务端发送一个 FIN 数据包；此时客户端进入 FIN_WAIT_1 状态，表示客户端需要断开连接
   - 服务端收到客户端发送的数据包，检测到 FIN 标志位，知道要断开连接。于是将 ACK 置为 seq + 1，然后向客户端回传一个 ACK 数据包；此时服务端进入 CLOSE_WAIT 状态；服务端告诉客户端，同意『关闭』请求，但是需要等一会儿
   - 客户端收到服务端发送的『确认包』后，进入 FIN_WAIT_2 状态，等待服务器准备完毕后再次发送数据包
   - 片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，随后服务端进入 LAST_ACK 状态
   - 客户端收到服务端发送的 FIN 数据包，再向服务端发送 ACK 数据包，告诉它可以断开连接，然后进入 TIME_WAIT 状态
   - 服务端收到 ACK 数据包之后就关闭连接，进入 CLOSED 状态；此时客户端等待 2MSL 之后依然没有收到回复，证明服务端已经正常关闭，那么客户端也可以关闭连接

   **缩写词**

   Seq：序号（Sequence Number），用来标识从计算机 A 发送到计算机 B 的数据包的序号，计算机发送数据时对此进行标记

   ACK：确认号（Acknowledge Number），客户端和服务器端都可以发送，Ack = Seq + 1

   SYN：同步（Synchronous），标志位，表示建立同步连接

    FIN：关闭（Finish），标志位，表示关闭连接

   MSL：报文最大生存时间（Maximum Segment Lifetime）

5. ### 为什么是三次握手而不是两次

   假设有一个场景，客户端发起的一次连接请求数据包并没有丢失，只是在网络节点中延迟了，这时候服务端接收到这个请求数据包之后，就会误认为是一个新的连接请求，于是就向客户端发起确认数据包，同意连接。而这时服务端就会一直等待客户端发送数据请求，但是这原本是一个过期的无效的连接，白白浪费了服务端的资源。如果加上第三次握手，服务端确认数据包后还需要客户端再确认一次，这样就可以建立有效连接

6. ### 为什么是四次挥手而不是两次或三次

   首先说两次挥手，好比在微信聊天的两个人，A 对 B 说我想睡觉了，而 B 正在滔滔不绝，这时断开连接就相当于 A 把 B 拉黑了，B 发送的消息被拒收了

   再说说三次挥手，同是在微信聊天的两个人，A 对 B 说我想睡觉了，而 B 收到消息后，把未说完的消息发了出去，然后想了一想觉得自己没什么要说的了，于是说了声『收到，88』，这时断开连接，会让 B 感觉到困惑，A 到底有没有收到我的消息。第四次挥手让双方确认，事情已经谈完可以 88 了

7. ### 为什么四次挥手的最后一步中，客户端需要等待 2MSL

   数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器的新的响应，就说明服务器已经收到了 ACK 包。

8. HTTP 与 HTTPS 的区别

9. TCP/IP 协议

10. 三次握手和四次挥手详细介绍

11. TCP 有哪些手段保证可靠交付

12. DNS 域名解析及如何优化

13. 五类 IP 地址

14. 正向代理和反向代理

15. CDN 带来的性能优化

16. HTTP 强缓存 & 协商缓存

17. 介绍 HTTPS 握手过程

18. HTTPS 握手过程中，客户端如何验证证书的合法性

19. 讲解一下 HTTPS 的工作原理

20. 讲解一下 HTTPS 对称加密和非对称加密

21. 如何劫持 HTTPS 请求

22. 如何预防中间人攻击

23. DNS解析会出错吗，为什么

24. 如何应对流量劫持

25. 谈谈 XSS 防御，以及 Content-Security-Policy 细节

26. 301 302 307 308 401 403

27. 一个 TCP 连接能发几个 HTTP 请求

    HTTP 1.0 
    一般情况下，不支持长连接，在每次请求发送完毕后会断开 TCP 连接，因此一个 TCP 连接能发送一个 HTTP 请求
    有种情况下，可以将 TCP 连接保持在活跃状态，通过 Connection 和 Keep-alive 首部，在请求头上加:
    Connection: keep-live，如果客户端和服务端都支持，也可以发送多条请求，不过有些限制。

    HTTP 1.1
    支持长连接，因此一个 TCP 连接在不断开的情况下，便可以一直发送 HTTP 请求，没有上限，持续发送。

    HTTP 2.0
    支持多用复用，同样支持长连接，因此在不断开连接的情况下，可以并行发送 HTTP 请求，没有上限，持续发送。

    

    

