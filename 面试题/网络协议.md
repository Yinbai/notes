# HTTP、TCP/IP面试题



1. ### OSI 网络模型

   应用层（HTTP/FTP）、表示层、会话层、传输层（TCP）、网络层（IP）、数据链路层、物理层

2. ### TCP/IP 网络模型

   应用层、传输层、网络层、数据链路层、物理层

3. ### TCP 和 UDP 的区别

   TCP 和 UDP 都是传输层的协议，区别如下

   TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。

   | TCP          | UDP            |
   | ------------ | -------------- |
   | 面向连接     | 无连接         |
   | 保证可靠交付 | 不保证可靠交付 |
   | 面向字节流   | 面向数据报     |
   | 点对点传播   | 广播           |
   | 有序         | 无序           |
   | 有状态       | 无状态         |

4. ### TCP 的三次握手和四次挥手

   **三次握手**

   - 客户端发起请求报文段，将 SYN 标志位设为 1，随机产生 Sequence Number 为 x，客户端进入 `SYN-SEND` 状态，等待服务端的确认
   - 服务端收到客户端的报文段，检测到已经设置了 SYN 标志位，知道这是客户端发来的建立连接的『请求包』。服务端也会组建一个报文段，并设置 ack 为 x + 1，SYN 位置为 1，随机产生 Sequence Number 为 y；随后服务端将这个报文段发送给客户端，服务端进入 `SYN-RECEIVED` 状态
   - 客户端收到服务端的报文段，检测到已经设置了 SYN 和 ACK 标志位，知道这是服务端发来的建立连接的『确认包』。客户端会检测 ack，看它的值是否是 x + 1。如果是，客户端继续组建报文段，并设置 ack 为 y + 1，然后向服务端发送 ACK 报文段。这个报文段发送之后，客户端进入 `建立连接` 状态，三次握手完成
   - 服务端收到客户端的报文段，检测到已经设置了 ACK 标志位，知道这是客户端发来的建立连接的『确认包』。服务端会检测 ack，看它的值是否是 y + 1，如果是就说明连接建立成功，服务端进入 `建立连接` 状态。
   - 至此，客户端和服务端之间的连接建立完成，可以收发数据

   **四次挥手**

   - 客户端设置 Sequence Number 和 ACK，向服务端发送一个 FIN 报文段；此时客户端进入 FIN_WAIT_1 状态，表示客户端需要断开连接
   - 服务端收到客户端发送的报文段，检测到 FIN 标志位，知道要断开连接。于是将 ack 置为 u + 1，然后向客户端回传一个 ACK 报文段；此时服务端进入 CLOSE_WAIT 状态；服务端告诉客户端，同意『关闭』请求，但是需要等一会儿
   - 客户端收到服务端发送的『确认包』后，进入 FIN_WAIT_2 状态，等待服务端准备完毕后再次发送报文段
   - 片刻后，服务端准备完毕，可以断开连接，于是再主动向客户端发送 FIN 报文段，随后服务端进入 LAST_ACK 状态
   - 客户端收到服务端发送的 FIN 报文段，再向服务端发送 ACK 报文段，告诉它可以断开连接，然后进入 TIME_WAIT 状态
   - 服务端收到 ACK 报文段之后就关闭连接，进入 CLOSED 状态；此时客户端等待 2MSL 之后依然没有收到回复，证明服务端已经正常关闭连接，那么客户端也可以关闭连接

   **缩写词**

    seq：序号（Sequence Number），用来标识从计算机 A 发送到计算机 B 的报文段的序号，计算机发送数据时对此进行标记

    ack：确认号（Acknowledge Number）

   ACK：确认（Acknowledge），标志位，客户端和服务端都可以发送，其值要么是 0 要么是 1

   SYN：同步（Synchronous），标志位，表示建立同步连接

    FIN：关闭（Finish），标志位，表示关闭连接

   MSL：报文最大生存时间（Maximum Segment Lifetime）

5. ### 为什么是三次握手而不是两次

   假设有一个场景，客户端发起的一次连接请求报文段并没有丢失，只是在网络节点中延迟了，这时候服务端接收到这个请求报文段之后，就会误认为是一个新的连接请求，于是就向客户端发起确认报文段，同意连接。而这时服务端就会一直等待客户端发送数据请求，但是这原本是一个过期的无效的连接，白白浪费了服务端的资源。如果加上第三次握手，服务端确认报文段后还需要客户端再确认一次，这样就可以建立有效连接

6. ### 为什么是四次挥手而不是两次或三次

   首先说两次挥手，好比在微信聊天的两个人，A 对 B 说我想睡觉了，而 B 正在滔滔不绝，这时断开连接就相当于 A 把 B 拉黑了，B 发送的消息被拒收了

   再说说三次挥手，同是在微信聊天的两个人，A 对 B 说我想睡觉了，而 B 收到消息后，把未说完的消息发了出去，然后想了一想觉得自己没什么要说的了，于是说了声『收到，88』。如果这时断开连接，会让 B 感觉到困惑，A 到底有没有收到我的消息。第四次挥手让双方确认，事情已经谈完可以 88 了

7. ### 为什么四次挥手的最后一步中，客户端需要等待 2MSL

   报文段在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。2MSL 是报文段往返的最大时间，如果 2MSL 后还未收到服务端的新的响应，就说明服务端已经收到了 ACK 包。

8. ### 如果已经建立了连接，但是客户端突然出现故障了怎么办

   TCP 设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 分钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

9. ### 什么是 HTTP 协议

   HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

10. ### 你知道哪些 HTTP 的请求方法

   ```
   GET - 获取资源（幂等）
   POST - 向指定资源提交要被处理的数据（非幂等）
   OPTIONS - 返回服务器支持的请求方法（幂等）
   PUT - 更新资源（幂等）
   DELETE - 删除指定资源（幂等）
   HEAD - 和 GET 类似，但只返回 HTTP 报文头部
   CONNECT
   TRACE
   ```

11. HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3 各版本之间的区别

12. HTTP 与 HTTPS 的区别

13. TCP/IP 协议

14. TCP 有哪些手段保证可靠交付

15. DNS 域名解析及如何优化

16. 五类 IP 地址

17. 正向代理和反向代理

18. CDN 带来的性能优化

19. HTTP 强缓存 & 协商缓存

20. 介绍 HTTPS 握手过程

21. HTTPS 握手过程中，客户端如何验证证书的合法性

22. 讲解一下 HTTPS 的工作原理

23. 讲解一下 HTTPS 对称加密和非对称加密

24. 如何劫持 HTTPS 请求

25. 如何预防中间人攻击

26. DNS解析会出错吗，为什么

27. 如何应对流量劫持

28. 谈谈 XSS 防御，以及 Content-Security-Policy 细节

29. 301 302 307 308 401 403

    ```
    301 和 302 | 303 | 307 | 308 都表示重定向。
    不同的是 301 是永久性重定向，表示访问资源不存在了，302 是临时性重定向，表示访问资源还在，但是需要跳转到另一个资源
    注意：302 会导致『网址劫持』，意思是访问 A 时 302 到 B，某些搜索引擎会使用 B 的内容，但却收录了 A 的地址
    ```

    

30. 一个 TCP 连接能发几个 HTTP 请求

    HTTP 1.0 
    一般情况下，不支持长连接，在每次请求发送完毕后会断开 TCP 连接，因此一个 TCP 连接能发送一个 HTTP 请求
    有种情况下，可以将 TCP 连接保持在活跃状态，通过 Connection 和 Keep-alive 首部，在请求头上加:
    Connection: keep-live，如果客户端和服务端都支持，也可以发送多条请求，不过有些限制。

    HTTP 1.1
    支持长连接，因此一个 TCP 连接在不断开的情况下，便可以一直发送 HTTP 请求，没有上限，持续发送。

    HTTP 2.0
    支持多用复用，同样支持长连接，因此在不断开连接的情况下，可以并行发送 HTTP 请求，没有上限，持续发送。

    

    

