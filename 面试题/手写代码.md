# 手写代码



#### Javascript

1. 实现一个 new

   ```javascript
   const _new = function(func) {
     let obj = {};
     if (typeof func === 'function') {
       obj = Object.create(func.prototype);
     }
     const res = func.apply(obj, Array.prototype.slice.call(arguments, 1))
     
     if (typeof res === 'object' || typeof res === 'function' && !res) {
       return res
     }
     return obj
   }
   
   function foo(name) {
     this.name = name
   }
   
   const f = _new(foo, 'kk')
   f.name // kk
   ```

   

2. 实现一个 instanceof

   ```javascript
   const instanceOf = function(obj, func) {
     if (typeof func !== 'function') return
     const prototype = func.prototype
     let proto = obj.__proto__
     
     while(true) {
       if (proto === null) {
         return false
       } else if (proto === prototype) {
         return true
       } else {
         proto = proto.__proto__
       }
     }
   }
   
   function foo() {}
   
   const f = new foo()
   const b = {}
   
   instanceOf(f, foo)
   instanceOf(b, foo)
   ```

   

3. 实现一个 typeof

   ```javascript
   
   ```

   

4. 实现一个继承

   ```javascript
   
   ```

   

5. 实现一个防抖/节流

   ```javascript
   // 防抖原理是约定在一段时间后在触发事件处理，每次触发事件处理都会重置计时器
   ```

   

6. 实现一个 call

   ```javascript
   Function.prototype._call = function(context, ...args) {
     context = context || window
     // 声明一个独有的 Symbol 属性, 防止 fn 覆盖已有属性
     const fn = Symbol('fn')
     // 将调用函数的 this 指向 obj
     context[fn] = this
     // 缓存结果，并删除临时添加的 fn
     const res = context[fn](...args)
     delete context[fn]
     
     return res
   }
   ```

   

7. 实现一个 apply

   ```javascript
   // 在 call 的基础上改下入参即可
   ```

   

8. 实现一个 bind

   ```javascript
   // 和 call/apply 不同的是，bind 会返回一个函数，且这个函数可以接受参数
   // 返回的绑定函数可以被 new 调用
   Function.prototype._bind = function(context, ...args) {
     if (typeof this !== "function") {
       throw new TypeError(
         "Function.prototype.bind - what is trying to be bound is not callable"
       );
     }
   
     context = context || window
     
     const self = this
     const bound = function() {
       const funcArgs = args.concat([...arguments])
       return self.apply(context, funcArgs)
     }
     bound.prototype = Object.create(self.prototype)
     
     return bound
   }
   
   var name = "Hero";
   var obj = {
     name: "Condor",
     fn: 12,
   };
   
   function foo() {
     console.log(this.name);
     console.log(...arguments);
   }
   const f1 = foo._bind(obj, 1, 2, 3);
   f1(); // Condor  1,2,3
   const nf = new foo();
   console.log(nf instanceof newfun); // true
   console.log(nf instanceof fun);  // true
   ```

   

9. 实现一个 sleep

   ```javascript
   
   ```

   

10. 实现一个 Promise

   ```javascript
   
   ```

   

11. 如何遍历一个 DOM 树 ?

    ```javascript
    
    ```

    

12. 冒泡排序

    ```javascript
    
    ```

    

13. 数组去重

    ```javascript
    
    ```

    

14. 扁平化数组

    ```javascript
    
    ```

    

15. ES5 中实现 let

    ```javascript
    // IIFE
    ```

    

16. ES5 中实现 const

    ```javascript
    // 通过 Object.defineProperty 来实现
    var _const = function(key, value) {
      Object.defineProperty(window, key, {
        writable: false,
        value
      })
    }
    
    _const('si', 'hello const')
    si = 'i can change it' // 不能改变值
    _const('ss', { a: 1 })
    ss = 'i can change it' // 不能改变引用类型的指针地址
    ss.b = 2					// 可以改变引用类型指针地址的数据结构
    ```



16. 实现一个 MVVM

    ```javascript
    
    ```

    

17. 实现一个 React

    ```javascript
    
    ```

    

18. 实现一个 Vue

    ```javascript
    
    ```

    

19. 实现一个 MV*

    ```javascript
    
    ```

    